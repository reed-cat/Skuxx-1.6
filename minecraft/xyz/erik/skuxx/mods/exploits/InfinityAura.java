package xyz.erik.skuxx.mods.exploits;

import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntitySnowball;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.pathfinding.PathEntity;
import net.minecraft.pathfinding.PathFinder;
import net.minecraft.pathfinding.PathPoint;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.world.pathfinder.WalkNodeProcessor;
import xyz.erik.api.friend.FriendManager;
import xyz.erik.api.helpers.ErikTimer;
import xyz.erik.api.helpers.Helper;
import xyz.erik.api.helpers.Location;
import xyz.erik.api.mod.Mod;
import xyz.erik.skuxx.Skuxx;
import xyz.erik.skuxx.event.Event;
import xyz.erik.skuxx.event.EventTarget;
import xyz.erik.skuxx.event.events.EventMotion;
import xyz.erik.skuxx.event.events.EventRender;
import xyz.erik.skuxx.mods.Category;

import java.util.ArrayList;
import java.util.List;

public class InfinityAura
extends Mod
{

    public EntityPlayer pos;
    public PathFinder pathFinder = new PathFinder(new WalkNodeProcessor());
    private List<EntityLivingBase> targets = new ArrayList<>();
    private EntityLivingBase target;
    int index;

    public InfinityAura() {

        setCategory(Category.EXPLOITS);
    }

    int currentIndex;
    private BlockPos curPos;
    private ErikTimer erikTimer = new ErikTimer();
    @EventTarget
    private void onMotionUpdatte(EventMotion eventMotion) {
        if (eventMotion.getMotion() == Event.Motion.BEFORE) {

            double max = 100;
            EntityLivingBase oldTarget = target;
            for(Object o : this.getWorld().loadedEntityList) {
                if (o instanceof EntityLivingBase) {
                    EntityLivingBase e = (EntityLivingBase)o;
                    if (checkEntity(e) && e.getDistanceToEntity(getPlayer()) < max)
                    {
                        this.target = e;
                        max = e.getDistanceToEntity(getPlayer());
                    }
                }
            }
            if (oldTarget != target || erikTimer.delay(3000)) {
                currentIndex = 0;
                erikTimer.reset();
            }
                if (target != null) {
                    float[] rotations = Helper.getRotationsAtLocation(Location.HEAD,target);
                    eventMotion.setRotationYaw(rotations[0]);
                    eventMotion.setRotationPitch(rotations[1]);
                    aps++;
                }
                if (target != null) {
                    eventMotion.setCancelled(true);

            }


        } else if(eventMotion.getMotion() == Event.Motion.AFTER) {
            if (checkEntity(target  )) {

                        if (getPlayer().isBlocking()) {
                            getPlayer().sendQueue.addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.RELEASE_USE_ITEM, BlockPos.ORIGIN, EnumFacing.UP));
                        }

                        C03PacketPlayer.C04PacketPlayerPosition packet = new C03PacketPlayer.C04PacketPlayerPosition(getPlayer().posX, getPlayer().posY, getPlayer().posZ, getPlayer().onGround);
                        double[] startPos = {getPlayer().posX, getPlayer().posY, getPlayer().posZ};
                    PathEntity pe = null;
                    if (getPlayer().getDistanceToEntity(target) > 5) {
                         pe = this.pathFinder.func_176188_a(getWorld(), getPlayer(), this.target, 40.0F);

                            if (pe != null && pe.getCurrentPathLength() > 1 && currentIndex + 1 < pe.getCurrentPathLength() && getPlayer().ticksExisted % 2 == 0 ) {

                                for (int i = 0; i < 1; i++) {
                                    if (increment(pe.getCurrentPathLength())) {

                                        PathPoint point = pe.getPathPointFromIndex(currentIndex);
                                        if (point == null) {
                                            continue;
                                        }
                                        getPlayer().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(point.xCoord, point.yCoord + 0.066, point.zCoord, true));
                                       // getPlayer().setPositionAndUpdate(point.xCoord,point.yCoord,point.zCoord);
                                        System.out.println("Did");

                                    }
                                }
                        }
                    }
                if (aps >= (20 / 5)) {

                        if (pe == null || currentIndex + 1 > pe.getCurrentPathLength()) {
                            getPlayer().swingItem();
                            getPlayer().sendPacket(new C02PacketUseEntity(this.target, C02PacketUseEntity.Action.ATTACK));
                            for(int i = 3; i > 0; i--) {
                                getPlayer().sendPacket(packet);
                                getPlayer().setPositionAndUpdate(packet.x, packet.y, packet.z);
                                aps = 0;
                            }
                        }

                }
            }
        }
    }

    private int aps;



    public boolean increment(int max) {
        currentIndex++;
        if (currentIndex > max)
        {
            currentIndex = 0;
            return false;
        }
        return true;
    }
    public List<EntityLivingBase> getTargets() {
        List<EntityLivingBase> entityLivingBases = new ArrayList<>();
        for(Object o : this.getMinecraft().theWorld.loadedEntityList) {
            if (o instanceof EntityLivingBase) {
                EntityLivingBase entityLivingBase = (EntityLivingBase)o;
                if(checkEntity(entityLivingBase)) {
                    entityLivingBases.add(entityLivingBase);
                }
            }
        }
        return entityLivingBases;
    }


    private boolean checkEntity(EntityLivingBase entityLivingBase){
        if (entityLivingBase == getPlayer()) {
            return false;
        }
        if (entityLivingBase.isDead) {
            return false;
        }
        if (entityLivingBase instanceof EntityPlayer && Skuxx.getInstance().getFriendManager().isFriend(entityLivingBase.getName())) return false;
        if (entityLivingBase.getDistanceToEntity(getPlayer()) > 40) {
            return false;
        }
        if (entityLivingBase.getDistanceToEntity(getPlayer()) > 50 && getPlayer().hurtResistantTime > 1) {
            return false;
        }
        return true;



    }

    public void blinkToPos(double[] startPos, BlockPos endPos, double slack)
    {
        double curX = startPos[0];
        double curY = startPos[1];
        double curZ = startPos[2];
        double endX = endPos.getX() + 0.5D;
        double endY = endPos.getY() + 1.0D;
        double endZ = endPos.getZ() + 0.5D;

        double distance = Math.abs(curX - endX) + Math.abs(curY - endY) + Math.abs(curZ - endZ);
        int count = 0;
        while (distance > slack)
        {
            distance = Math.abs(curX - endX) + Math.abs(curY - endY) + Math.abs(curZ - endZ);
            if (count > 120) {
                break;
            }
            double diffX = curX - endX;
            double diffY = curY - endY;
            double diffZ = curZ - endZ;

            double offset = (count & 0x1) == 0 ? 0.4D : 0.25D;
            if (diffX < 0.0D) {
                if (Math.abs(diffX) > offset) {
                    curX += offset;
                } else {
                    curX += Math.abs(diffX);
                }
            }
            if (diffX > 0.0D) {
                if (Math.abs(diffX) > offset) {
                    curX -= offset;
                } else {
                    curX -= Math.abs(diffX);
                }
            }
            if (diffY < 0.0D) {
                if (Math.abs(diffY) > 0.25D) {
                    curY += 0.25D;
                } else {
                    curY += Math.abs(diffY);
                }
            }
            if (diffY > 0.0D) {
                if (Math.abs(diffY) > 0.25D) {
                    curY -= 0.25D;
                } else {
                    curY -= Math.abs(diffY);
                }
            }
            if (diffZ < 0.0D) {
                if (Math.abs(diffZ) > offset) {
                    curZ += offset;
                } else {
                    curZ += Math.abs(diffZ);
                }
            }
            if (diffZ > 0.0D) {
                if (Math.abs(diffZ) > offset) {
                    curZ -= offset;
                } else {
                    curZ -= Math.abs(diffZ);
                }
            }
            getMinecraft().getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(curX, curY, curZ, true));
            count++;
        }
    }




}
